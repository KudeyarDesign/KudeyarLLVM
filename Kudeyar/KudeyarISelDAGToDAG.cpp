//===-------- KudeyarISelDAGToDAG.cpp ---------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
// Year: 2017
// Alexey Shistko     alexey@kudeyar.com
// Andrei Safronov    andrei@kudeyar.com
//===----------------------------------------------------------------------===//
#define DEBUG_TYPE "kudeyar-isel"

#include "Kudeyar.h"
#include "KudeyarTargetMachine.h"
#include "llvm/CallingConv.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAG.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/Constants.h"
#include "llvm/DerivedTypes.h"
#include "llvm/Function.h"
#include "llvm/Intrinsics.h"
#include "llvm/Support/Compiler.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetLowering.h"
using namespace llvm;

namespace 
{
  struct KudeyarISelAddressMode 
  {
    enum 
	{
      RegBase,
      FrameIndexBase
    } BaseType;

    struct 
	{            // This is really a union, discriminated by BaseType!
      SDValue Reg;
      int FrameIndex;
    } Base;

    int16_t Disp;
    const GlobalValue *GV;
    const Constant *CP;
    const BlockAddress *BlockAddr;
    const char *ES;
    int JT;
    unsigned Align;    // CP alignment.

    KudeyarISelAddressMode()
      : BaseType(RegBase), Disp(0), GV(0), CP(0), BlockAddr(0),
        ES(0), JT(-1), Align(0) 
	{
    }

    bool hasSymbolicDisplacement() const 
	{
      return GV != 0 || CP != 0 || ES != 0 || JT != -1;
    }

    void dump() 
	{
      errs() << "KudeyarISelAddressMode " << this << '\n';
      if (BaseType == RegBase && Base.Reg.getNode() != 0) 
	  {
        errs() << "Base.Reg ";
        Base.Reg.getNode()->dump();
      } 
	  else if (BaseType == FrameIndexBase) 
	  {
        errs() << " Base.FrameIndex " << Base.FrameIndex << '\n';
      }
      errs() << " Disp " << Disp << '\n';
      if (GV) 
	  {
        errs() << "GV ";
        GV->dump();
      } 
	  else if (CP) 
	  {
        errs() << " CP ";
        CP->dump();
        errs() << " Align" << Align << '\n';
      } 
	  else if (ES) 
	  {
        errs() << "ES ";
        errs() << ES << '\n';
      } 
	  else if (JT != -1)
        errs() << " JT" << JT << " Align" << Align << '\n';
    }
  };


class KudeyarDAGToDAGISel : public SelectionDAGISel 
{
  /// TM - Keep a reference to KudeyarTargetMachine.
  KudeyarTargetMachine &TM;
  const KudeyarTargetLowering &Lowering;

  /// Subtarget - Keep a pointer to the Cpu0Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  const KudeyarSubtarget &Subtarget;

public:
  KudeyarDAGToDAGISel(KudeyarTargetMachine &TM, CodeGenOpt::Level OptLevel)
      : SelectionDAGISel(TM, OptLevel),
        Lowering(*TM.getTargetLowering()),
        Subtarget(*TM.getSubtargetImpl()), TM(TM) { }
  
  // Pass Name
  virtual const char *getPassName() const 
  {
    return "Kudeyar DAG->DAG Pattern Instruction Selection";
  }

  virtual bool runOnMachineFunction(MachineFunction &MF);

private:
  // Include the pieces autogenerated from the target description.
  #include "KudeyarGenDAGISel.inc"

  /// getTargetMachine - Return a reference to the TargetMachine, casted
  /// to the target-specific type.
  const KudeyarTargetMachine &getTargetMachine() 
  {
    return static_cast<const KudeyarTargetMachine &>(TM);
  }

  /// getInstrInfo - Return a reference to the TargetInstrInfo, casted
  /// to the target-specific type.
  const KudeyarInstrInfo *getInstrInfo() 
  {
    return getTargetMachine().getInstrInfo();
  }

  bool MatchAddress(SDValue N, KudeyarISelAddressMode &AM);
  bool MatchWrapper(SDValue N, KudeyarISelAddressMode &AM);
  bool MatchAddressBase(SDValue N, KudeyarISelAddressMode &AM);

  SDNode *Select(SDNode *N);

  // Complex Pattern.
  bool SelectAddr(SDNode *Parent, SDValue N, SDValue &Base, SDValue &Offset);
  SDNode* SelectIndexedLoad(SDNode *N);
  SDNode* SelectIndexedStore(SDNode *N); 
  SDNode* SelectIndexedBinOpLoad(SDNode *Op, SDValue N1, SDValue N2,
                             unsigned Opc8, unsigned Opc16, unsigned Opc32);
  SDNode* SelectIndexedBinOpStore(SDNode *StOp, SDValue Op, SDValue N1, SDValue N2,
                             unsigned Opc8, unsigned Opc16, unsigned Opc32);

  // getImm - Return a target constant with the specified value.
  inline SDValue getImm(const SDNode *Node, unsigned Imm) 
  {
    return CurDAG->getTargetConstant(Imm, Node->getValueType(0));
  }
};
} // end anonymous namespace

/// createKudeyarISelDag - This pass converts a legalized DAG into a
/// Kudeyar-specific DAG, ready for instruction scheduling.
///
FunctionPass *llvm::createKudeyarISelDag(KudeyarTargetMachine &TM,
                                        CodeGenOpt::Level OptLevel) 
{
  return new KudeyarDAGToDAGISel(TM, OptLevel);
}

bool KudeyarDAGToDAGISel::runOnMachineFunction(MachineFunction &MF) 
{
  bool Ret = SelectionDAGISel::runOnMachineFunction(MF);

  return Ret;
}

/// MatchWrapper - Try to match KudeyarISD::Wrapper node into an addressing mode.
/// These wrap things that will resolve down into a symbol reference.  If no
/// match is possible, this returns true, otherwise it returns false.
bool KudeyarDAGToDAGISel::MatchWrapper(SDValue N, KudeyarISelAddressMode &AM) 
{
  // If the addressing mode already has a symbol as the displacement, we can
  // never match another symbol.
  if (AM.hasSymbolicDisplacement())
    return true;

  SDValue N0 = N.getOperand(0);

  if (GlobalAddressSDNode *G = dyn_cast<GlobalAddressSDNode>(N0)) 
  {
    AM.GV = G->getGlobal();
    AM.Disp += G->getOffset();
    //AM.SymbolFlags = G->getTargetFlags();
  } 
  else if (ConstantPoolSDNode *CP = dyn_cast<ConstantPoolSDNode>(N0)) 
  {
    AM.CP = CP->getConstVal();
    AM.Align = CP->getAlignment();
    AM.Disp += CP->getOffset();
    //AM.SymbolFlags = CP->getTargetFlags();
  } 
  else if (ExternalSymbolSDNode *S = dyn_cast<ExternalSymbolSDNode>(N0)) 
  {
    AM.ES = S->getSymbol();
    //AM.SymbolFlags = S->getTargetFlags();
  } 
  else if (JumpTableSDNode *J = dyn_cast<JumpTableSDNode>(N0)) 
  {
    AM.JT = J->getIndex();
    //AM.SymbolFlags = J->getTargetFlags();
  } 
  else 
  {
    AM.BlockAddr = cast<BlockAddressSDNode>(N0)->getBlockAddress();
    //AM.SymbolFlags = cast<BlockAddressSDNode>(N0)->getTargetFlags();
  }
  return false;
}

/// MatchAddressBase - Helper for MatchAddress. Add the specified node to the
/// specified addressing mode without any further recursion.
bool KudeyarDAGToDAGISel::MatchAddressBase(SDValue N, KudeyarISelAddressMode &AM) 
{
   // Is the base register already occupied?
  if (AM.BaseType != KudeyarISelAddressMode::RegBase || AM.Base.Reg.getNode()) 
  {
    // If so, we cannot select it.
    return true;
  }

  // Default, generate it as a register.
  AM.BaseType = KudeyarISelAddressMode::RegBase;
  AM.Base.Reg = N;
  return false;
}

bool KudeyarDAGToDAGISel::MatchAddress(SDValue N, KudeyarISelAddressMode &AM) 
{
//  DEBUG(errs() << "MatchAddress: "; AM.dump());

//  errs() << "opcode = " << N.getOpcode() << '\n';
//  N.dump();
//  errs() << '\n';

  switch (N.getOpcode()) 
  {
  default: break;
  case ISD::Constant: 
  {
    uint64_t Val = cast<ConstantSDNode>(N)->getSExtValue();
    AM.Disp += Val;
    return false;
  }

  case KudeyarISD::Wrapper:
    if (!MatchWrapper(N, AM))
      return false;
    break;

  case ISD::FrameIndex:
    if (AM.BaseType == KudeyarISelAddressMode::RegBase
        && AM.Base.Reg.getNode() == 0) 
	{
      AM.BaseType = KudeyarISelAddressMode::FrameIndexBase;
      AM.Base.FrameIndex = cast<FrameIndexSDNode>(N)->getIndex();
      return false;
    }
    break;

  case ISD::ADD: 
  {
    KudeyarISelAddressMode Backup = AM;
    if (!MatchAddress(N.getNode()->getOperand(0), AM) &&
        !MatchAddress(N.getNode()->getOperand(1), AM))
      return false;
    AM = Backup;
    if (!MatchAddress(N.getNode()->getOperand(1), AM) &&
        !MatchAddress(N.getNode()->getOperand(0), AM))
      return false;
    AM = Backup;

    break;
  }

  case ISD::OR:
    // Handle "X | C" as "X + C" iff X is known to have C bits clear.
    if (ConstantSDNode *CN = dyn_cast<ConstantSDNode>(N.getOperand(1))) {
      KudeyarISelAddressMode Backup = AM;
      uint64_t Offset = CN->getSExtValue();
      // Start with the LHS as an addr mode.
      if (!MatchAddress(N.getOperand(0), AM) &&
          // Address could not have picked a GV address for the displacement.
          AM.GV == NULL &&
          // Check to see if the LHS & C is zero.
          CurDAG->MaskedValueIsZero(N.getOperand(0), CN->getAPIntValue())) {
        AM.Disp += Offset;
        return false;
      }
      AM = Backup;
    }
    break;
  }

  return MatchAddressBase(N, AM);
}


/// SelectAddr - returns true if it is able pattern match an addressing mode.
/// It returns the operands which make up the maximal addressing mode it can
/// match by reference.
bool KudeyarDAGToDAGISel::SelectAddr(SDNode* Parent, SDValue N,
                                    SDValue &Base, SDValue &Disp) 
{
  KudeyarISelAddressMode AM;

  if (MatchAddress(N, AM))
    return false;

 // AM.dump();

  if (AM.GV  ||  AM.ES  ||  AM.JT != -1)
    return false;

  EVT VT = N.getValueType();
  if (AM.BaseType == KudeyarISelAddressMode::RegBase) 
  {
    if (!AM.Base.Reg.getNode())
      AM.Base.Reg = CurDAG->getRegister(0, VT);
  }

  Base  = (AM.BaseType == KudeyarISelAddressMode::FrameIndexBase) ?
    CurDAG->getTargetFrameIndex(AM.Base.FrameIndex, TLI.getPointerTy()) :
    AM.Base.Reg;

  if (AM.GV)
    Disp = CurDAG->getTargetGlobalAddress(AM.GV, N->getDebugLoc(),
                                          MVT::i32, AM.Disp,
                                          0/*AM.SymbolFlags*/);
  else if (AM.CP)
    Disp = CurDAG->getTargetConstantPool(AM.CP, MVT::i32,
                                         AM.Align, AM.Disp, 0/*AM.SymbolFlags*/);
  else if (AM.ES)
    Disp = CurDAG->getTargetExternalSymbol(AM.ES, MVT::i32, 0/*AM.SymbolFlags*/);
  else if (AM.JT != -1)
    Disp = CurDAG->getTargetJumpTable(AM.JT, MVT::i32, 0/*AM.SymbolFlags*/);
  else if (AM.BlockAddr)
    Disp = CurDAG->getTargetBlockAddress(AM.BlockAddr, MVT::i32, 0,
                                         0/*AM.SymbolFlags*/);
  else
    Disp = CurDAG->getTargetConstant(AM.Disp, MVT::i32);

  return true;
}

/// Select instructions not customized! Used for
/// expanded, promoted and normal instructions
SDNode* KudeyarDAGToDAGISel::Select(SDNode *Node) 
{
  unsigned Opcode = Node->getOpcode();
  DebugLoc dl = Node->getDebugLoc();

  // Dump information about the Node being selected
  //  DEBUG(errs() << "Selecting: "; Node->dump(CurDAG); errs() << "\n");

  // If we have a custom node, we already have selected!
  if (Node->isMachineOpcode()) 
  {
    DEBUG(errs() << "== "; Node->dump(CurDAG); errs() << "\n");
    return NULL;
  }

  ///
  // Instruction Selection not handled by the auto-generated
  // tablegen selection should be handled here.
  ///
  EVT NodeTy = Node->getValueType(0);

  switch (Opcode) 
  {
    case ISD::FrameIndex: 
	{
      assert(Node->getValueType(0) == MVT::i32);
      int FI = cast<FrameIndexSDNode>(Node)->getIndex();
      SDValue TFI = CurDAG->getTargetFrameIndex(FI, MVT::i32);
      if (Node->hasOneUse())
        return CurDAG->SelectNodeTo(Node, Kudeyar::ADD_RI32, MVT::i32,
                                  TFI, CurDAG->getTargetConstant(0, MVT::i32));
      return CurDAG->getMachineNode(Kudeyar::ADD_RI32, dl, MVT::i16,
                                  TFI, CurDAG->getTargetConstant(0, MVT::i32));
    }
    case ISD::LOAD:
      if (SDNode *ResNode = SelectIndexedLoad(Node))
        return ResNode;
      // Other cases are autogenerated.
      break;
	case ISD::STORE:
	  {
        SDValue DataN = Node->getOperand(1);
	    unsigned Opcode2 = DataN->getOpcode();
	    switch (Opcode2)
	    {
		  case ISD::ADD:
            if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(0), DataN.getOperand(1),
                           Kudeyar::ADD_MR8_POST, Kudeyar::ADD_MR8_POST, Kudeyar::ADD_MR32_POST))
              return ResNode;
			else if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(1), DataN.getOperand(0),
                           Kudeyar::ADD_MR8_POST, Kudeyar::ADD_MR8_POST, Kudeyar::ADD_MR32_POST))
              return ResNode;
	        break;
		  case ISD::SUB:
            if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(0), DataN.getOperand(1),
                           Kudeyar::SUB_MR8_POST, Kudeyar::SUB_MR8_POST, Kudeyar::SUB_MR32_POST))
              return ResNode;
			else if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(1), DataN.getOperand(0),
                           Kudeyar::SUB_MR8_POST, Kudeyar::SUB_MR8_POST, Kudeyar::SUB_MR32_POST))
              return ResNode;
	        break;
		  case ISD::AND:
            if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(0), DataN.getOperand(1),
                           Kudeyar::AND_MR8_POST, Kudeyar::AND_MR8_POST, Kudeyar::AND_MR32_POST))
              return ResNode;
			else if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(1), DataN.getOperand(0),
                           Kudeyar::AND_MR8_POST, Kudeyar::AND_MR8_POST, Kudeyar::AND_MR32_POST))
              return ResNode;
	        break;
		  case ISD::OR:
            if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(0), DataN.getOperand(1),
                           Kudeyar::OR_MR8_POST, Kudeyar::OR_MR8_POST, Kudeyar::OR_MR32_POST))
              return ResNode;
			else if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(1), DataN.getOperand(0),
                           Kudeyar::OR_MR8_POST, Kudeyar::OR_MR8_POST, Kudeyar::OR_MR32_POST))
              return ResNode;
	        break;
		  case ISD::XOR:
            if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(0), DataN.getOperand(1),
                           Kudeyar::XOR_MR8_POST, Kudeyar::XOR_MR8_POST, Kudeyar::XOR_MR32_POST))
              return ResNode;
			else if (SDNode *ResNode =
              SelectIndexedBinOpStore(Node, DataN,
                           DataN.getOperand(1), DataN.getOperand(0),
                           Kudeyar::XOR_MR8_POST, Kudeyar::XOR_MR8_POST, Kudeyar::XOR_MR32_POST))
              return ResNode;
	        break;
	   }
       if (SDNode *ResNode = SelectIndexedStore(Node))
          return ResNode;
	  }
      break;
    case ISD::ADD:
      if (SDNode *ResNode =
          SelectIndexedBinOpLoad(Node,
                           Node->getOperand(0), Node->getOperand(1),
                           Kudeyar::ADDSX_RM8_POST, Kudeyar::ADDSX_RM8_POST, Kudeyar::ADD_RM32_POST))
        return ResNode;
      else if (SDNode *ResNode =
             SelectIndexedBinOpLoad(Node, Node->getOperand(1), Node->getOperand(0),
                                Kudeyar::ADDSX_RM8_POST, Kudeyar::ADDSX_RM8_POST, Kudeyar::ADD_RM32_POST))
        return ResNode;

      break;
    case ISD::SUB:
      if (SDNode *ResNode =
          SelectIndexedBinOpLoad(Node,
                           Node->getOperand(0), Node->getOperand(1),
                           Kudeyar::SUBSX_RM8_POST, Kudeyar::SUBSX_RM8_POST, Kudeyar::SUB_RM32_POST))
        return ResNode;
      else if (SDNode *ResNode =
             SelectIndexedBinOpLoad(Node, Node->getOperand(1), Node->getOperand(0),
                                Kudeyar::SUBSX_RM8_POST, Kudeyar::SUBSX_RM8_POST, Kudeyar::SUB_RM32_POST))
        return ResNode;
 
      break;
    case ISD::AND:
      if (SDNode *ResNode =
          SelectIndexedBinOpLoad(Node,
                           Node->getOperand(0), Node->getOperand(1),
                           Kudeyar::AND_RM8_POST, Kudeyar::AND_RM8_POST, Kudeyar::AND_RM32_POST))
        return ResNode;
      else if (SDNode *ResNode =
             SelectIndexedBinOpLoad(Node, Node->getOperand(1), Node->getOperand(0),
                                Kudeyar::AND_RM8_POST, Kudeyar::AND_RM8_POST, Kudeyar::AND_RM32_POST))
        return ResNode;
 
      break;
    case ISD::OR:
      if (SDNode *ResNode =
          SelectIndexedBinOpLoad(Node,
                           Node->getOperand(0), Node->getOperand(1),
                           Kudeyar::OR_RM8_POST, Kudeyar::OR_RM8_POST, Kudeyar::OR_RM32_POST))
        return ResNode;
      else if (SDNode *ResNode =
             SelectIndexedBinOpLoad(Node, Node->getOperand(1), Node->getOperand(0),
                                Kudeyar::OR_RM8_POST, Kudeyar::OR_RM8_POST, Kudeyar::OR_RM32_POST))
        return ResNode;
 
      break;
    case ISD::XOR:
      if (SDNode *ResNode =
          SelectIndexedBinOpLoad(Node,
                           Node->getOperand(0), Node->getOperand(1),
                           Kudeyar::XOR_RM8_POST, Kudeyar::XOR_RM8_POST, Kudeyar::XOR_RM32_POST))
        return ResNode;
      else if (SDNode *ResNode =
             SelectIndexedBinOpLoad(Node, Node->getOperand(1), Node->getOperand(0),
                                Kudeyar::XOR_RM8_POST, Kudeyar::XOR_RM8_POST, Kudeyar::XOR_RM32_POST))
        return ResNode;
 
      break;
    default: break;

  }

  // Select the default instruction
  SDNode *ResNode = SelectCode(Node);

  DEBUG(errs() << "=> ");
  if (ResNode == NULL || ResNode == Node)
    DEBUG(Node->dump(CurDAG));
  else
    DEBUG(ResNode->dump(CurDAG));
  DEBUG(errs() << "\n");
  return ResNode;
}

static bool isValidIndexedLoad(const LoadSDNode *LD) 
{
  ISD::MemIndexedMode AM = LD->getAddressingMode();
   if (AM != ISD::POST_INC /* || LD->getExtensionType() != ISD::NON_EXTLOAD */)
    return false;

  EVT VT = LD->getMemoryVT();

  switch (VT.getSimpleVT().SimpleTy) 
  {
    case MVT::i8:
      // Sanity check
      if (cast<ConstantSDNode>(LD->getOffset())->getZExtValue() != 1)
        return false;
      break;
    case MVT::i16:
      // Sanity check
      if (cast<ConstantSDNode>(LD->getOffset())->getZExtValue() != 2)
        return false;
      break;
   case MVT::i32:
      // Sanity check
      if (cast<ConstantSDNode>(LD->getOffset())->getZExtValue() != 4)
        return false;
      break;
    default:
      return false;
  }

  return true;
}

static bool isValidIndexedStore(const StoreSDNode *ST) 
{
  ISD::MemIndexedMode AM = ST->getAddressingMode();
  if (AM != ISD::POST_INC)
    return false;

  EVT VT = ST->getMemoryVT();

  switch (VT.getSimpleVT().SimpleTy) 
  {
    case MVT::i8:
      // Sanity check
      if (cast<ConstantSDNode>(ST->getOffset())->getZExtValue() != 1)
        return false;
      break;
    case MVT::i16:
      // Sanity check
      if (cast<ConstantSDNode>(ST->getOffset())->getZExtValue() != 2)
        return false;
      break;
   case MVT::i32:
      // Sanity check
      if (cast<ConstantSDNode>(ST->getOffset())->getZExtValue() != 4)
        return false;
      break;
    default:
      return false;
  }

  return true;
}

SDNode *KudeyarDAGToDAGISel::SelectIndexedLoad(SDNode *N) 
{
  LoadSDNode *LD = cast<LoadSDNode>(N);
  if (!isValidIndexedLoad(LD))
    return NULL;

  MVT VT = LD->getMemoryVT().getSimpleVT();

  unsigned Opcode = 0;
  switch (VT.SimpleTy) 
  {
    case MVT::i8:
      if (LD->getExtensionType() == ISD::SEXTLOAD)
        Opcode = Kudeyar::MOVSX_RM8_POST;
	  else  Opcode = Kudeyar::MOVZX_RM8_POST;
      break;

    case MVT::i16:
      if (LD->getExtensionType() == ISD::SEXTLOAD)
        Opcode = Kudeyar::MOVSX_RM16_POST;
	  else  Opcode = Kudeyar::MOVZX_RM16_POST;
	  break;
	case MVT::i32:
      Opcode = Kudeyar::MOV_RM32_POST;
	  break;
    default:
      return NULL;
  }

   SDNode* res= CurDAG->getMachineNode(Opcode, N->getDebugLoc(),
                                 MVT::i32, MVT::i32, MVT::Other,
                                 LD->getBasePtr(), LD->getChain());

/*
  errs() << "From Node N:\n";
  N->dump();
  errs() << "To Node N:\n";
  res->dump();
*/
  return res;
}

SDNode *KudeyarDAGToDAGISel::SelectIndexedStore(SDNode *N) 
{
  StoreSDNode *ST = cast<StoreSDNode>(N);
  if (!isValidIndexedStore(ST))
    return NULL;

  MVT VT = ST->getMemoryVT().getSimpleVT();

  unsigned Opcode = 0;
  switch (VT.SimpleTy) 
  {
    case MVT::i8:
      Opcode = Kudeyar::MOV_MR8_POST;
      break;
    case MVT::i16:
      Opcode = Kudeyar::MOV_MR16_POST;
	  break;
	case MVT::i32:
      Opcode = Kudeyar::MOV_MR32_POST;
	  break;
    default:
      return NULL;
  }

   SDNode* res= CurDAG->getMachineNode(Opcode, N->getDebugLoc(),
                                 MVT::i32, MVT::Other,
								 ST->getValue(), ST->getBasePtr(), ST->getChain());

  return res;
}

SDNode *KudeyarDAGToDAGISel::SelectIndexedBinOpLoad(SDNode *Op,
                                               SDValue N1, SDValue N2,
                                               unsigned Opc8, unsigned Opc16, unsigned Opc32) 
{
  if (N1.getOpcode() == ISD::LOAD &&
      N1.hasOneUse() &&
      IsLegalToFold(N1, Op, Op, OptLevel)) 
  {
    LoadSDNode *LD = cast<LoadSDNode>(N1);
    if (!isValidIndexedLoad(LD))
      return NULL;

    MVT VT = LD->getMemoryVT().getSimpleVT();
     unsigned Opc = (VT == MVT::i32 ? Opc32 : VT == MVT::i16 ? Opc16 : Opc8);
    MachineSDNode::mmo_iterator MemRefs0 = MF->allocateMemRefsArray(1);
    MemRefs0[0] = cast<MemSDNode>(N1)->getMemOperand();
    SDValue Ops0[] = { N2, LD->getBasePtr(), LD->getChain() };
    SDNode *ResNode =
      CurDAG->SelectNodeTo(Op, Opc,
                           VT, MVT::i32, MVT::Other,
                           Ops0, 3);
    cast<MachineSDNode>(ResNode)->setMemRefs(MemRefs0, MemRefs0 + 1);
    // Transfer chain.
    ReplaceUses(SDValue(N1.getNode(), 2), SDValue(ResNode, 2));
    // Transfer writeback.
    ReplaceUses(SDValue(N1.getNode(), 1), SDValue(ResNode, 1));
    return ResNode;
  }

  return NULL;
}

SDNode *KudeyarDAGToDAGISel::SelectIndexedBinOpStore(SDNode *StOp, SDValue Op,
                                               SDValue N1, SDValue N2,
                                               unsigned Opc8, unsigned Opc16, unsigned Opc32) 
{
  SDNode* NOp = Op.getNode();
  StoreSDNode* StN = cast<StoreSDNode>(StOp);
//  errs() << "Valid Indexed Store 1\n";	 
//  errs() << "AM = " << StN->getAddressingMode() << '\n';
//  errs() << (N1.getOpcode() == ISD::LOAD) << "  " << N1.hasOneUse() << "  " << IsLegalToFold(N1, StOp, StOp, OptLevel) << "\n";
  if (!isValidIndexedStore(StN))
    return NULL;
//  errs() << "Valid Indexed Store 2\n";
  if (N1.getOpcode() == ISD::LOAD &&
      N1.hasOneUse() && 
      IsLegalToFold(N1, NOp, NOp, OptLevel)) 
  {
/*
    errs() << "Valid Indexed Store 3\n";
    errs() << "StOp =\n";
    StOp->dump();
    errs() << "\n";
    errs() << "Op =\n";
    Op.dump();
    errs() << "\n";
    errs() << "N1 = \n";
    N1.dump();
    errs() << "\n";
    errs() << "N2 = \n";
    N2.dump();
    errs() << "\n";
*/
	LoadSDNode* LD = cast<LoadSDNode>(N1.getNode());

	if (StOp->getOperand(2) != LD->getOperand(1))
      return NULL;

    MVT VT = LD->getMemoryVT().getSimpleVT();
    unsigned Opc = (VT == MVT::i32 ? Opc32 : VT == MVT::i16 ? Opc16 : Opc8);
    MachineSDNode::mmo_iterator MemRefs0 = MF->allocateMemRefsArray(1);
    MemRefs0[0] = cast<MemSDNode>(N1)->getMemOperand();
    SDValue Ops0[] = { LD->getBasePtr(), N2, LD->getChain() };
    SDNode *ResNode =
      CurDAG->SelectNodeTo(StOp, Opc,
                           MVT::i32, MVT::Other,
                           Ops0, 3);
    cast<MachineSDNode>(ResNode)->setMemRefs(MemRefs0, MemRefs0 + 1);
    // Transfer chain.
    ReplaceUses(SDValue(N1.getNode(), 2), SDValue(ResNode, 2));
    // Transfer writeback.
    ReplaceUses(SDValue(N1.getNode(), 1), SDValue(ResNode, 1));

//	if (ResNode != NULL)
//	  ResNode->dump();
    return ResNode;
  }

  return NULL;
}